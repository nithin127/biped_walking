# Author: Nithin Vasishta
# Last Edited: 26th August

import numpy as np
import mujoco as mj
from scipy.spatial.transform import Rotation as R

import utils.stance_utils as st_utils
from utils.inertia_utils import calculate_inertia

from infrastructure.qp_solver import QPSolver
from infrastructure.single_rigid_body_dynamics import SingleRigidBodyModel


PI = np.pi

class StanceLegController():

    def __init__ (self, model, data, args, task_info):

        self.model = model
        self.data = data
        self.args = args
        self.task_info = task_info

        self.max_z_force = 1000
        self.mpc_param_id = None

        self.mass = task_info.robot["init_mass"]
        self.inertia = task_info.robot["init_inertia"]
        self.srbm = SingleRigidBodyModel(self.mass, self.inertia, 2, 0.1, args.planning_horizon)     


    def reset_qp_solver(self):

        if self.mpc_param_id == self.args.mpc_weights_config:
            pass

        else:
            self.mpc_param_id = self.args.mpc_weights_config
            K_i, L_i = st_utils.get_KL(self.mpc_param_id)
            self.qp_solver = QPSolver(L_i, K_i, self.args.planning_horizon)


    def get_action(self, phase):

        if phase < PI:

            first_swing_leg = "Right"
            foot_contact_states = np.array([0, 1]) # Left foot stance

            ibody_shank = self.task_info.robot["body_left_shank_id"]
            isite_foot = self.task_info.robot["site_left_foot_mid_id"]
            start_index_qv = self.task_info.robot["qvel_left_leg_start_id"]
            foot_positions_world = np.array([np.zeros(3), self.data.site_xpos[isite_foot]])

        else:

            first_swing_leg = "Left"
            foot_contact_states = np.array([1, 0]) # Right foot stance

            ibody_shank = self.task_info.robot["body_right_shank_id"]
            isite_foot = self.task_info.robot["site_right_foot_mid_id"]
            start_index_qv = self.task_info.robot["qvel_right_leg_start_id"]
            foot_positions_world = np.array([self.data.site_xpos[isite_foot], np.zeros(3)])


        info = {
                "ctrl": "mpc",
                "Jr": None, 
                "Jl": None, 
                "force": [0, 0, 0, 0, 0, 0], 
                "torque_st": [0, 0, 0],
                "x_ref": None, 
                "x_res": None,
            }


        ## Setup Single Rigid Body Model (SRBM)

        # We use spatial frame (frame positioned at torso, but no rotation w.r.t. world frame)
        # Here, torso_pos is [0, 0, 0] for x_init

        if self.args.added_weight_known:
        
            i_st = self.task_info.robot["body_start_id"]
            i_end = self.task_info.robot["body_end_id"] + 1
            self.mass = np.sum(self.model.body_mass[i_st:i_end])
            self.inertia = calculate_inertia(self.model, self.data, self.task_info.robot, "wrt_torso")
            self.srbm = SingleRigidBodyModel(self.mass, self.inertia, 2, 0.1, self.args.planning_horizon)     
                    
        else:
            pass

        torso_pos = self.data.xpos[1]
        torso_quat_mj = self.data.xquat[1]
        # Mujoco uses [w, x, y, z] as quat, SciPy uses [x, y, z, w]
        torso_quat = np.concatenate([torso_quat_mj[1:], torso_quat_mj[:1]])
        torso_rpy = R.from_quat(torso_quat).as_euler('xyz')

        torso_velocity = self.data.qvel[0:3]
        angular_velocity_torso = self.data.qvel[3:6]
        foot_positions_torso_frame = foot_positions_world - torso_pos
        terrain_slope = self.task_info.terrain['ground_slope'](torso_pos[0])


        x_init = np.array([*list(torso_rpy), *list([0, 0, 0]),  # Note: torso_pos is zero w.r.t. torso spatial frame
                           *angular_velocity_torso, *torso_velocity, -9.81])
        ref_desired_stats = st_utils.get_desired_reference_values(phase, self.data, self.args, self.task_info, \
                                                                  torso_pos, torso_rpy)


        A, B = self.srbm.prepareModel(torso_rpy, foot_contact_states, foot_positions_torso_frame, discretize=True)
        x_ref = self.srbm.getReferenceTraj(x_init, ref_desired_stats, terrain_slope)

        friction_coeffs = [self.model.geom_friction[4][0], self.model.geom_friction[7][0]] # Right and Left shank (foot)
        c, C = self.srbm.getForceConstraints(friction_coeffs, self.max_z_force)


        ## Solve Quadratic Program to get required forces 

        A_qp, B_qp = self.qp_solver.get_qp_matrices(A, B)
        U_qp = self.qp_solver.solve_qp(A, B, x_init, x_ref, (c, C))
        U = -1*U_qp # Force generated by joints = -1 * Force needed to move the body forward

        # For testing purposes
        x_res = A_qp@x_init - B_qp@U


        ## Forces to Torques using jacobian

        jacp = np.zeros((3, self.model.nv))
        mj.mj_jac(self.model, self.data, jacp, None, self.data.site_xpos[isite_foot], ibody_shank)
        J = jacp[:, start_index_qv:start_index_qv+3]
            
        if first_swing_leg == "Right":
            torque_st = J.T@U[3:6]

        elif first_swing_leg == "Left":
            torque_st = J.T@U[0:3]
        
        info = {
                "ctrl": "mpc",
                "J": J, 
                "force": U, 
                "torque_st": torque_st,
                "x_ref": x_ref, 
                "x_res": x_res,
            }
        
        # print(info["force"][:6])
        # print(info["torque_st"])
        # input("")

        return torque_st, info
